-- LIMIT   ( 첫 번째 인자는 시작점, 첫 파라미터는 0부터 시작한다.)
SELECT
	   MENU_CODE,
       MENU_NAME,
       MENU_PRICE
  FROM TBL_MENU
 ORDER BY MENU_PRICE DESC;
 
SELECT
	   MENU_CODE,
       MENU_NAME,
       MENU_PRICE
  FROM TBL_MENU
 ORDER BY MENU_PRICE DESC
 LIMIT 1, 4;
 
SELECT
	   MENU_CODE,
       MENU_NAME,
       MENU_PRICE
  FROM TBL_MENU
 ORDER BY MENU_PRICE DESC,
		  MENU_NAME ASC
 LIMIT 5;
 
-- JOIN
SELECT
	   MENU_CODE AS 'CODE',
       MENU_NAME AS NAME,
       MENU_PRICE PRICE
  FROM TBL_MENU
 ORDER BY PRICE; 
 
SELECT
	   A.CATEGORY_CODE,
       A.MENU_CODE
  FROM TBL_MENU A
 ORDER BY A.CATEGORY_CODE, A.MENU_NAME;
 
-- INNER JOIN

SELECT
	   A.MENU_NAME,
       B.CATEGORY_NAME
  FROM TBL_MENU A
  JOIN TBL_CATEGORY B ON (A.CATEGORY_CODE = B.CATEGORY_CODE);
  
-- 컬럼명이 JOIN 할 테이블과 같을 경우 USING을 사용한다.  
SELECT
	   A.MENU_CODE,
       B.CATEGORY_NAME
  FROM TBL_MENU A 
  INNER JOIN TBL_CATEGORY B USING(CATEGORY_CODE);
  
-- LEFT JOIN : 첫 번째(왼쪽) 테이블의 모든 레코드와 두 번째 테이블에서 일치하는 레코드를 반환하는 JOIN 유형
SELECT
	   A.CATEGORY_NAME,
       B.MENU_NAME
  FROM TBL_CATEGORY A
  RIGHT JOIN TBL_MENU B ON (A.CATEGORY_CODE = B.CATEGORY_CODE);
  
-- CROSS JOIN :  두 테이블의 모든 가능한 조합을 반환하는 JOIN 유형
SELECT
	   A.MENU_NAME,
       B.CATEGORY_NAME
  FROM TBL_MENU A
 CROSS JOIN TBL_CATEGORY B; 

-- SELF JOIN : 같은 테이블 내에서 행과 행 사이의 관계를 찾기 위해 사용되는 유형
SELECT
	   A.CATEGORY_NAME,
       B.CATEGORY_NAME
  FROM TBL_CATEGORY A
  JOIN TBL_CATEGORY B ON (A.REF_CATEGORY_CODE = B.CATEGORY_CODE)
 WHERE A.REF_CATEGORY_CODE IS NOT NULL;
 
-- NESTED LOOP JOIN
SELECT
	   A.MENU_NAME,
       B.CATEGORY_NAME
  FROM TBL_MENU A
  JOIN TBL_CATEGORY B ON (A.CATEGORY_CODE = B.CATEGORY_CODE);

	